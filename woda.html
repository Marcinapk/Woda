<!doctype html>
<html lang="pl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Kalkulator zapotrzebowania na wodę (Single-File)</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; background: #f6f7fb; color: #111; }
    .header { padding: 16px; background: #111; color: #fff; }
    .header h1 { margin: 0 0 6px; font-size: 18px; }
    .header p { margin: 0; opacity: .85; font-size: 13px; }

    .container { padding: 12px; display: grid; gap: 12px; max-width: 1100px; margin: 0 auto; }
    .card { background: #fff; border-radius: 12px; padding: 12px; box-shadow: 0 1px 6px rgba(0,0,0,.08); }
    .card h2 { margin: 0 0 10px; font-size: 16px; }

    .subcard { margin-top: 12px; padding-top: 12px; border-top: 1px solid #eef0f6; }
    .subcard h3 { margin: 0 0 10px; font-size: 14px; }

    .grid { display: grid; gap: 10px; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); }
    label { display: grid; gap: 6px; font-size: 13px; }
    input, select { padding: 10px; border: 1px solid #d8dbe6; border-radius: 10px; font-size: 16px; background: #fff; }

    .row { display: flex; gap: 10px; align-items: center; justify-content: space-between; flex-wrap: wrap; }
    .btn { padding: 10px 12px; border: 1px solid #d8dbe6; background: #fff; border-radius: 10px; font-size: 14px; cursor: pointer; }
    .btn.primary { background: #111; border-color: #111; color: #fff; }
    .btn.danger { background: #fff; border-color: #d33; color: #d33; }
    .btn:disabled { opacity: .55; cursor: not-allowed; }

    input:focus, .btn:focus, select:focus {
      outline: 3px solid rgba(17,17,17,.15);
      outline-offset: 2px;
      border-color: #111;
    }

    .tableWrap { overflow: auto; border: 1px solid #eef0f6; border-radius: 10px; }
    table { width: 100%; border-collapse: collapse; min-width: 920px; }
    th, td { padding: 10px; border-bottom: 1px solid #eef0f6; font-size: 13px; vertical-align: top; }
    th { text-align: left; background: #fafbff; }
    td input, td select { width: 100%; box-sizing: border-box; font-size: 16px; padding: 8px; }

    .summary { margin-top: 10px; font-size: 13px; }
    .hint { margin-top: 10px; font-size: 12px; opacity: .8; }

    .results { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 10px; margin-top: 10px; }
    .result { border: 1px solid #eef0f6; border-radius: 10px; padding: 10px; }
    .result .k { font-size: 12px; opacity: .75; }
    .result .v { font-size: 18px; margin-top: 4px; font-variant-numeric: tabular-nums; }

    .status { border-radius: 12px; padding: 12px; border: 1px solid #eef0f6; margin-top: 10px; }
    .statusTitle { font-weight: 700; margin-bottom: 6px; }
    .status.neutral { background: #fafbff; }
    .status.ok { background: #f1fff4; border-color: #b7f0c3; }
    .status.bad { background: #fff2f2; border-color: #f0b7b7; }
    .status.warn { background: #fff8e6; border-color: #f3d08a; }

    @media print {
      body { background: #fff; }
      .header { background: #fff; color: #111; border-bottom: 1px solid #ddd; }
      .btn, .row button { display: none !important; }
      .card { box-shadow: none; border: 1px solid #ddd; }
      .tableWrap { overflow: visible; }
      table { min-width: 0; }
    }
  </style>
</head>

<body>
  <header class="header">
    <h1>Kalkulator zapotrzebowania na wodę</h1>
    <p>Wpisz dane → Oblicz → wynik + zapas + OK / BRAK WODY</p>
  </header>

  <main class="container">
    <section class="card">
      <h2>Parametry pożaru</h2>
      <div class="grid">
        <label>
          Powierzchnia pożaru A [m²]
          <input id="A" type="number" inputmode="decimal" min="0" step="0.01" value="800" />
        </label>

        <label>
          Gęstość obciążenia ogniowego q<sub>d</sub> [MJ/m²]
          <input id="qd" type="number" inputmode="decimal" min="0" step="1" value="500" />
        </label>

        <label>
          Intensywność I [l/s·m²]
          <input id="I" type="number" inputmode="decimal" min="0" step="0.01" value="0.2" />
        </label>
      </div>

      <div class="hint">
        Czas t [h] dobierany jest z tabeli progów (jak w Excelu). Dla qd poniżej minimalnego progu przyjmowany jest minimalny czas z tabeli.
      </div>
    </section>

    <section class="card">
      <div class="row">
        <h2>Wozy pożarnicze (magazyn wody)</h2>
        <button id="addVehicle" class="btn" type="button">Dodaj pojazd</button>
      </div>

      <div class="tableWrap">
        <table id="vehiclesTable">
          <thead>
            <tr>
              <th>Nazwa pojazdu</th>
              <th>Pojemność zbiornika [l]</th>
              <th></th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>

      <div class="summary">
        Suma wody w pojazdach: <strong><span id="sumWater">0</span> l</strong>
      </div>
    </section>

    <section class="card">
      <h2>Źródła wody zewnętrzne</h2>

      <div class="subcard">
        <div class="row">
          <h3>Hydranty zewnętrzne (sieć ppoż – gwarancja 2h)</h3>
          <button id="addHydrant" class="btn" type="button">Dodaj hydrant</button>
        </div>

        <div class="tableWrap">
          <table id="hydrantsTable">
            <thead>
              <tr>
                <th>Opis</th>
                <th>Typ</th>
                <th>Liczba</th>
                <th>Q łącznie [l/min]</th>
                <th>V w 2h [l]</th>
                <th></th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>

        <div class="summary">
          Hydranty: <strong>Q = <span id="hydQ">0</span> l/min</strong>,
          <strong>V(2h) = <span id="hydV2h">0</span> l</strong>
        </div>

        <div class="status warn" id="hydrantWarn" style="display:none;">
          <div class="statusTitle">UWAGA</div>
          <div class="statusDesc">
            Do obliczeń przyjęto, że sieć ppoż (hydranty) jest gwarantowana przez <strong>2 godziny</strong>.
            Po 2 godzinach zasilanie może działać dalej, ale tego nie gwarantujemy w bilansie – traktujemy jak limit.
          </div>
        </div>
      </div>

      <div class="subcard">
        <div class="row">
          <h3>Zbiorniki / inne magazyny wody</h3>
          <button id="addTank" class="btn" type="button">Dodaj zbiornik</button>
        </div>

        <div class="tableWrap">
          <table id="tanksTable">
            <thead>
              <tr>
                <th>Opis</th>
                <th>Pojemność wpisana [l]</th>
                <th>Dł. [m]</th>
                <th>Szer. [m]</th>
                <th>Gł. [m]</th>
                <th>Pojemność z wymiarów [l]</th>
                <th>Pojemność użyta [l]</th>
                <th></th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>

        <div class="summary">
          Zbiorniki (magazyn): <strong>V = <span id="tankV">0</span> l</strong>
        </div>

        <div class="hint">
          Jeżeli wpiszesz pojemność [l], to ona ma pierwszeństwo. Jeśli zostawisz 0 – liczona jest z wymiarów (L×W×H).
        </div>
      </div>

      <div class="subcard">
        <div class="row">
          <h3>Cieki wodne (przekrój + przepływ)</h3>
          <button id="addRiver" class="btn" type="button">Dodaj ciek</button>
        </div>

        <div class="grid">
          <label>
            Limit czasu zasilania z cieków do bilansu [min] (domyślnie 2h)
            <input id="riverMinutes" type="number" min="0" step="1" value="120" />
          </label>

          <label>
            Województwo (do uśrednienia — jeśli działa połączenie HTTP/HTTPS)
            <select id="voivodeship">
              <option value="podkarpackie" selected>podkarpackie</option>
              <option value="mazowieckie">mazowieckie</option>
              <option value="malopolskie">małopolskie</option>
              <option value="lubelskie">lubelskie</option>
              <option value="slaskie">śląskie</option>
              <option value="dolnoslaskie">dolnośląskie</option>
              <option value="wielkopolskie">wielkopolskie</option>
              <option value="pomorskie">pomorskie</option>
              <option value="zachodniopomorskie">zachodniopomorskie</option>
              <option value="kujawsko-pomorskie">kujawsko-pomorskie</option>
              <option value="lodzkie">łódzkie</option>
              <option value="swietokrzyskie">świętokrzyskie</option>
              <option value="podlaskie">podlaskie</option>
              <option value="warminsko-mazurskie">warmińsko-mazurskie</option>
              <option value="lubuskie">lubuskie</option>
              <option value="opolskie">opolskie</option>
            </select>
          </label>

          <div class="row" style="align-items:flex-end;">
            <button id="fetchRiverAvg" class="btn" type="button">Pobierz średni przepływ (IMGW)</button>
          </div>
        </div>

        <div class="tableWrap">
          <table id="riversTable">
            <thead>
              <tr>
                <th>Opis</th>
                <th>Szer. [m]</th>
                <th>Gł. [m]</th>
                <th>Pole przekroju [m²]</th>
                <th>Przepływ Q [m³/s]</th>
                <th>Q [l/min]</th>
                <th>Prędkość v [m/s]</th>
                <th></th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>

        <div class="summary">
          Cieki: <strong>Q = <span id="riverQ">0</span> l/min</strong>,
          <strong>V(limit) = <span id="riverV">0</span> l</strong>
        </div>

        <div class="hint">
          Uwaga: przy uruchomieniu jako plik (file:// / content://) przeglądarka może blokować pobieranie danych IMGW. Wtedy wpisz Q ręcznie.
        </div>
      </div>
    </section>

    <section class="card">
      <div class="row">
        <h2>Prądy gaśnicze (wydatki planowane)</h2>
        <button id="addStream" class="btn" type="button">Dodaj prąd</button>
      </div>

      <div class="tableWrap">
        <table id="streamsTable">
          <thead>
            <tr>
              <th>Opis</th>
              <th>Wydatek 1 prądu [l/min]</th>
              <th>Liczba prądów</th>
              <th>Łączny wydatek [l/min]</th>
              <th></th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
      </div>

      <div class="summary">
        Całkowity wydatek (Q<sub>avail</sub>): <strong><span id="qAvail">0</span> l/min</strong>
      </div>
    </section>

    <section class="card">
      <div class="row">
        <button id="calc" class="btn primary" type="button">Oblicz</button>
        <button id="save" class="btn" type="button">Zapisz ustawienia</button>
        <button id="reset" class="btn danger" type="button">Reset</button>
      </div>
    </section>

    <section class="card">
      <h2>Wynik</h2>

      <div id="statusBox" class="status neutral">
        <div class="statusTitle">—</div>
        <div class="statusDesc">Wprowadź dane i kliknij „Oblicz”.</div>
      </div>

      <div class="results">
        <div class="result">
          <div class="k">Czas pożaru t</div>
          <div class="v"><span id="tHours">—</span> h</div>
        </div>
        <div class="result">
          <div class="k">Wymagany przepływ Q<sub>req</sub></div>
          <div class="v"><span id="qReq">—</span> l/min</div>
        </div>
        <div class="result">
          <div class="k">Wymagana ilość wody V</div>
          <div class="v"><span id="vLiters">—</span> l</div>
        </div>
        <div class="result">
          <div class="k">Rzeczywista intensywność I<sub>real</sub></div>
          <div class="v"><span id="iReal">—</span> l/s·m²</div>
        </div>
        <div class="result">
          <div class="k">Zapas intensywności</div>
          <div class="v"><span id="reserveI">—</span>%</div>
        </div>
        <div class="result">
          <div class="k">Czas zapewnienia wody (bilans)</div>
          <div class="v"><span id="tAvail">—</span> min</div>
        </div>
        <div class="result">
          <div class="k">Zapas czasowy</div>
          <div class="v"><span id="reserveT">—</span>%</div>
        </div>
      </div>

      <div class="hint">
        „OK” oznacza jednocześnie spełnienie: Q<sub>avail</sub> ≥ Q<sub>req</sub> oraz czas zapewnienia ≥ czas wymagany.
      </div>
    </section>
  </main>

  <script>
    // ==============================
    // Kalkulator zapotrzebowania na wodę (Single-File)
    // + hydranty (2h), zbiorniki, cieki wodne
    // + IMGW: uśrednianie po województwie (może nie działać przy file://)
    // ==============================

    // Tabela qd -> t [h] (LOOKUP: największy próg <= qd)
    const qdTable = [
      { qd: 200,  t: 0.3 },
      { qd: 1800, t: 2.0 },
      { qd: 2600, t: 3.0 },
      { qd: 3400, t: 4.0 },
      { qd: 3900, t: 5.0 },
      { qd: 4500, t: 6.0 },
      { qd: 5100, t: 7.0 },
      { qd: 5900, t: 8.0 },
    ];

    // Hydranty: wg Twojego założenia
    // DN80  = 10 dm3/s = 10 l/s
    // DN100 = 15 dm3/s = 15 l/s
    const HYDRANT_TYPES = [
      { key: "DN80",  ls: 10 },
      { key: "DN100", ls: 15 },
    ];
    const HYDRANT_GUARANTEE_MIN = 120; // 2h

    function $(id) {
      const el = document.getElementById(id);
      if (!el) throw new Error(`Brak elementu o id="${id}" w HTML.`);
      return el;
    }

    const els = {
      // parametry
      A: $("A"),
      qd: $("qd"),
      I: $("I"),

      // wozy
      vehiclesTbody: document.querySelector("#vehiclesTable tbody"),
      addVehicle: $("addVehicle"),
      sumWater: $("sumWater"),

      // hydranty
      hydrantsTbody: document.querySelector("#hydrantsTable tbody"),
      addHydrant: $("addHydrant"),
      hydQ: $("hydQ"),
      hydV2h: $("hydV2h"),
      hydrantWarn: $("hydrantWarn"),

      // zbiorniki
      tanksTbody: document.querySelector("#tanksTable tbody"),
      addTank: $("addTank"),
      tankV: $("tankV"),

      // cieki
      riversTbody: document.querySelector("#riversTable tbody"),
      addRiver: $("addRiver"),
      riverMinutes: $("riverMinutes"),
      riverQ: $("riverQ"),
      riverV: $("riverV"),
      voivodeship: $("voivodeship"),
      fetchRiverAvg: $("fetchRiverAvg"),

      // prądy
      streamsTbody: document.querySelector("#streamsTable tbody"),
      addStream: $("addStream"),
      qAvail: $("qAvail"),

      // akcje
      calc: $("calc"),
      save: $("save"),
      reset: $("reset"),

      // wynik
      statusBox: $("statusBox"),
      tHours: $("tHours"),
      qReq: $("qReq"),
      vLiters: $("vLiters"),
      iReal: $("iReal"),
      reserveI: $("reserveI"),
      tAvail: $("tAvail"),
      reserveT: $("reserveT"),
    };

    function n(v) {
      const x = Number(v);
      return Number.isFinite(x) ? x : 0;
    }
    function round(x, d = 2) {
      const p = Math.pow(10, d);
      return Math.round(x * p) / p;
    }
    function escapeHtml(s) {
      return String(s)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;")
        .replace(/'/g, "&#039;");
    }

    function lookupFireTimeHours(qd) {
      const q = n(qd);
      if (q <= 0) return 0;
      let t = 0;
      for (const row of qdTable) {
        if (q >= row.qd) t = row.t;
      }
      if (t === 0 && q > 0) t = qdTable[0].t; // odporność na qd < min progu
      return t; // h
    }

    // --------------------
    // Row builders
    // --------------------
    function vehicleRow(name = "", liters = 0) {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td><input class="v-name" type="text" value="${escapeHtml(name)}" placeholder="np. GBA 3,5/29"></td>
        <td><input class="v-liters" type="number" inputmode="decimal" min="0" step="1" value="${n(liters)}"></td>
        <td><button class="btn danger v-del" type="button">Usuń</button></td>
      `;
      tr.querySelector(".v-del").addEventListener("click", () => { tr.remove(); recalcLive(); });
      tr.querySelectorAll("input").forEach(inp => inp.addEventListener("input", recalcLive));
      return tr;
    }

    function hydrantRow(desc = "Hydrant zewnętrzny", typeKey = "DN80", count = 1) {
      const tr = document.createElement("tr");
      const opts = HYDRANT_TYPES.map(t => `<option value="${t.key}" ${t.key===typeKey ? "selected":""}>${t.key}</option>`).join("");
      tr.innerHTML = `
        <td><input class="h-desc" type="text" value="${escapeHtml(desc)}"></td>
        <td><select class="h-type">${opts}</select></td>
        <td><input class="h-count" type="number" min="0" step="1" value="${n(count)}"></td>
        <td class="h-q">0</td>
        <td class="h-v">0</td>
        <td><button class="btn danger h-del" type="button">Usuń</button></td>
      `;
      tr.querySelector(".h-del").addEventListener("click", () => { tr.remove(); recalcLive(); });
      tr.querySelectorAll("input, select").forEach(inp => inp.addEventListener("input", recalcLive));
      return tr;
    }

    function tankRow(desc = "Zbiornik", volL = 0, Lm = 0, Wm = 0, Dm = 0) {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td><input class="t-desc" type="text" value="${escapeHtml(desc)}"></td>
        <td><input class="t-vol" type="number" min="0" step="1" value="${n(volL)}"></td>
        <td><input class="t-L" type="number" min="0" step="0.01" value="${n(Lm)}"></td>
        <td><input class="t-W" type="number" min="0" step="0.01" value="${n(Wm)}"></td>
        <td><input class="t-D" type="number" min="0" step="0.01" value="${n(Dm)}"></td>
        <td class="t-vdim">0</td>
        <td class="t-vuse">0</td>
        <td><button class="btn danger t-del" type="button">Usuń</button></td>
      `;
      tr.querySelector(".t-del").addEventListener("click", () => { tr.remove(); recalcLive(); });
      tr.querySelectorAll("input").forEach(inp => inp.addEventListener("input", recalcLive));
      return tr;
    }

    function riverRow(desc = "Ciek", width = 0, depth = 0, q_m3s = 0) {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td><input class="r-desc" type="text" value="${escapeHtml(desc)}"></td>
        <td><input class="r-w" type="number" min="0" step="0.01" value="${n(width)}"></td>
        <td><input class="r-d" type="number" min="0" step="0.01" value="${n(depth)}"></td>
        <td class="r-area">0</td>
        <td><input class="r-q" type="number" min="0" step="0.001" value="${n(q_m3s)}"></td>
        <td class="r-qlm">0</td>
        <td class="r-v">0</td>
        <td><button class="btn danger r-del" type="button">Usuń</button></td>
      `;
      tr.querySelector(".r-del").addEventListener("click", () => { tr.remove(); recalcLive(); });
      tr.querySelectorAll("input").forEach(inp => inp.addEventListener("input", recalcLive));
      return tr;
    }

    function streamRow(desc = "", one = 0, count = 0) {
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td><input class="s-desc" type="text" value="${escapeHtml(desc)}" placeholder="np. Linia W-52..."></td>
        <td><input class="s-one" type="number" inputmode="decimal" min="0" step="1" value="${n(one)}"></td>
        <td><input class="s-count" type="number" inputmode="decimal" min="0" step="1" value="${n(count)}"></td>
        <td class="s-total">0</td>
        <td><button class="btn danger s-del" type="button">Usuń</button></td>
      `;
      tr.querySelector(".s-del").addEventListener("click", () => { tr.remove(); recalcLive(); });
      tr.querySelectorAll("input").forEach(inp => inp.addEventListener("input", recalcLive));
      return tr;
    }

    // --------------------
    // Getters
    // --------------------
    function getVehicles() {
      return [...els.vehiclesTbody.querySelectorAll("tr")].map(tr => ({
        name: tr.querySelector(".v-name").value.trim(),
        liters: n(tr.querySelector(".v-liters").value),
      }));
    }
    function getHydrants() {
      return [...els.hydrantsTbody.querySelectorAll("tr")].map(tr => ({
        desc: tr.querySelector(".h-desc").value.trim(),
        type: tr.querySelector(".h-type").value,
        count: n(tr.querySelector(".h-count").value),
      }));
    }
    function getTanks() {
      return [...els.tanksTbody.querySelectorAll("tr")].map(tr => ({
        desc: tr.querySelector(".t-desc").value.trim(),
        volL: n(tr.querySelector(".t-vol").value),
        Lm: n(tr.querySelector(".t-L").value),
        Wm: n(tr.querySelector(".t-W").value),
        Dm: n(tr.querySelector(".t-D").value),
      }));
    }
    function getRivers() {
      return [...els.riversTbody.querySelectorAll("tr")].map(tr => ({
        desc: tr.querySelector(".r-desc").value.trim(),
        w: n(tr.querySelector(".r-w").value),
        d: n(tr.querySelector(".r-d").value),
        q_m3s: n(tr.querySelector(".r-q").value),
      }));
    }
    function getStreams() {
      return [...els.streamsTbody.querySelectorAll("tr")].map(tr => ({
        desc: tr.querySelector(".s-desc").value.trim(),
        one: n(tr.querySelector(".s-one").value),
        count: n(tr.querySelector(".s-count").value),
      }));
    }

    // --------------------
    // Sums + UI updates
    // --------------------
    function calcSums() {
      // wozy (magazyn)
      const vehicles = getVehicles();
      const vVehicles = vehicles.reduce((a, v) => a + n(v.liters), 0);
      els.sumWater.textContent = String(round(vVehicles, 0));

      // prądy (planowany wydatek)
      const streams = getStreams();
      let qAvail = 0;
      const sTrs = [...els.streamsTbody.querySelectorAll("tr")];
      streams.forEach((s, i) => {
        const total = n(s.one) * n(s.count);
        qAvail += total;
        const cell = sTrs[i]?.querySelector(".s-total");
        if (cell) cell.textContent = String(round(total, 0));
      });
      els.qAvail.textContent = String(round(qAvail, 0));

      // hydranty (zasilanie ciągłe, do bilansu jako gwarantowane 2h)
      const hydrants = getHydrants();
      let qHyd_lmin = 0;
      const hTrs = [...els.hydrantsTbody.querySelectorAll("tr")];
      hydrants.forEach((h, i) => {
        const type = HYDRANT_TYPES.find(t => t.key === h.type) ?? HYDRANT_TYPES[0];
        const q_ls = type.ls * n(h.count); // l/s
        const q_lmin = q_ls * 60;          // l/min
        qHyd_lmin += q_lmin;

        const v2h = q_lmin * HYDRANT_GUARANTEE_MIN; // l
        const qCell = hTrs[i]?.querySelector(".h-q");
        const vCell = hTrs[i]?.querySelector(".h-v");
        if (qCell) qCell.textContent = String(round(q_lmin, 0));
        if (vCell) vCell.textContent = String(round(v2h, 0));
      });

      const vHyd_full_2h = qHyd_lmin * HYDRANT_GUARANTEE_MIN;
      els.hydQ.textContent = String(round(qHyd_lmin, 0));
      els.hydV2h.textContent = String(round(vHyd_full_2h, 0));
      els.hydrantWarn.style.display = (hydrants.length > 0) ? "" : "none";

      // zbiorniki (magazyn)
      const tanks = getTanks();
      let vTanks = 0;
      const tTrs = [...els.tanksTbody.querySelectorAll("tr")];
      tanks.forEach((t, i) => {
        const vDim = Math.max(0, n(t.Lm) * n(t.Wm) * n(t.Dm) * 1000); // m3 -> l
        const vUse = (n(t.volL) > 0) ? n(t.volL) : vDim;
        vTanks += vUse;

        const cellDim = tTrs[i]?.querySelector(".t-vdim");
        const cellUse = tTrs[i]?.querySelector(".t-vuse");
        if (cellDim) cellDim.textContent = String(round(vDim, 0));
        if (cellUse) cellUse.textContent = String(round(vUse, 0));
      });
      els.tankV.textContent = String(round(vTanks, 0));

      // cieki (zasilanie ciągłe z limitem czasu do bilansu)
      const rivers = getRivers();
      let qRiver_lmin = 0;
      const rTrs = [...els.riversTbody.querySelectorAll("tr")];
      rivers.forEach((r, i) => {
        const area = Math.max(0, n(r.w) * n(r.d)); // m2
        const q_m3s = Math.max(0, n(r.q_m3s));
        const q_ls = q_m3s * 1000; // m3/s -> l/s
        const q_lmin = q_ls * 60;  // l/min
        qRiver_lmin += q_lmin;

        const v_ms = (area > 0) ? (q_m3s / area) : 0;

        const cellArea = rTrs[i]?.querySelector(".r-area");
        const cellQLM = rTrs[i]?.querySelector(".r-qlm");
        const cellV = rTrs[i]?.querySelector(".r-v");
        if (cellArea) cellArea.textContent = String(round(area, 3));
        if (cellQLM) cellQLM.textContent = String(round(q_lmin, 0));
        if (cellV) cellV.textContent = String(round(v_ms, 3));
      });

      const riverMin = Math.max(0, n(els.riverMinutes.value));
      const vRiver_full = qRiver_lmin * riverMin;

      els.riverQ.textContent = String(round(qRiver_lmin, 0));
      els.riverV.textContent = String(round(vRiver_full, 0));

      return {
        qAvail,
        vVehicles,
        vTanks,
        qHyd_lmin,
        qRiver_lmin,
        riverMin,
        vHyd_full_2h,
        vRiver_full,
      };
    }

    // --------------------
    // Status + compute
    // --------------------
    function setStatus(type, title, desc) {
      els.statusBox.className = `status ${type}`;
      const titleEl = els.statusBox.querySelector(".statusTitle");
      const descEl = els.statusBox.querySelector(".statusDesc");
      if (titleEl) titleEl.textContent = title;
      if (descEl) descEl.textContent = desc;
    }

    function compute() {
      const A = n(els.A.value);
      const qd = n(els.qd.value);
      const I = n(els.I.value);

      const tHours = lookupFireTimeHours(qd);     // [h]
      const qReq_ls = A * I;                      // [l/s]
      const qReq_lmin = qReq_ls * 60;             // [l/min]
      const vReqLiters = qReq_ls * tHours * 3600; // [l]

      const s = calcSums();

      // Bilans intensywności (jak wcześniej – oparty o Q_avail)
      const iReal = (A > 0) ? ((s.qAvail / 60) / A) : 0;  // [l/s·m²]
      const reserveI = (I > 0) ? ((iReal / I - 1) * 100) : 0;

      // Bilans czasu zapewnienia wody:
      // - magazyn: wozy + zbiorniki
      const storageLiters = s.vVehicles + s.vTanks;

      // - zasilanie ciągłe: do bilansu liczymy "wolumen użyteczny" przy Q_avail
      //   (żeby nie zawyżać, gdy Q_zasilania > Q_avail)
      const usableHyd = Math.min(s.qHyd_lmin, s.qAvail) * HYDRANT_GUARANTEE_MIN; // [l]
      const usableRiver = Math.min(s.qRiver_lmin, s.qAvail) * s.riverMin;       // [l]

      const totalUsableLiters = storageLiters + usableHyd + usableRiver;

      const tAvailMin = (s.qAvail > 0) ? (totalUsableLiters / s.qAvail) : 0; // [min]
      const tReqMin = tHours * 60;

      const reserveT = (tReqMin > 0) ? ((tAvailMin / tReqMin - 1) * 100) : 0;

      // Warunki OK
      const okFlow = (s.qAvail >= qReq_lmin) && qReq_lmin > 0;
      const okTime = (tAvailMin >= tReqMin) && tReqMin > 0;

      // Wyniki
      els.tHours.textContent = String(round(tHours, 2));
      els.qReq.textContent = String(round(qReq_lmin, 0));
      els.vLiters.textContent = String(round(vReqLiters, 0));
      els.iReal.textContent = String(round(iReal, 3));
      els.reserveI.textContent = String(round(reserveI, 1));
      els.tAvail.textContent = String(round(tAvailMin, 1));
      els.reserveT.textContent = String(round(reserveT, 1));

      // Status
      if (A <= 0 || I <= 0 || qd <= 0) {
        setStatus("bad", "BRAK DANYCH", "Uzupełnij A, qd oraz I (wartości > 0).");
        return;
      }
      if (!okFlow && !okTime) {
        setStatus("bad", "BRAK WODY", "Brak wymaganej wydajności (l/min) oraz brak zapewnienia czasu (bilans litrowy).");
        return;
      }
      if (!okFlow) {
        setStatus("bad", "BRAK WODY", "Brak wymaganej wydajności (Q_avail < Q_req).");
        return;
      }
      if (!okTime) {
        setStatus("bad", "BRAK WODY", "Wydajność jest OK, ale brak zapewnienia czasu (bilans litrowy za krótki).");
        return;
      }

      const notes = [];
      if (s.qHyd_lmin > 0) notes.push("hydranty liczone jako gwarantowane 2h");
      if (s.qRiver_lmin > 0 && s.riverMin > 0) notes.push(`cieki liczone z limitem ${round(s.riverMin,0)} min`);
      const extra = (notes.length > 0) ? ` Uwaga: ${notes.join(", ")}.` : "";

      setStatus("ok", "OK", "Wydajność i czas zapewnienia spełniają wymagania (zapas pokazany w %)." + extra);
    }

    function recalcLive() {
      calcSums();
    }

    // --------------------
    // Save/load/reset
    // --------------------
    function saveState() {
      const state = {
        A: els.A.value,
        qd: els.qd.value,
        I: els.I.value,
        riverMinutes: els.riverMinutes.value,
        voivodeship: els.voivodeship.value,
        vehicles: getVehicles(),
        hydrants: getHydrants(),
        tanks: getTanks(),
        rivers: getRivers(),
        streams: getStreams(),
      };
      localStorage.setItem("kalkulator_wody_state_singlefile", JSON.stringify(state));
      setStatus("neutral", "ZAPISANO", "Ustawienia zapisane lokalnie w urządzeniu.");
    }

    function loadState() {
      const raw = localStorage.getItem("kalkulator_wody_state_singlefile");
      if (!raw) return false;

      try {
        const s = JSON.parse(raw);

        els.A.value = s.A ?? els.A.value;
        els.qd.value = s.qd ?? els.qd.value;
        els.I.value = s.I ?? els.I.value;

        els.riverMinutes.value = s.riverMinutes ?? els.riverMinutes.value;
        els.voivodeship.value = s.voivodeship ?? els.voivodeship.value;

        els.vehiclesTbody.innerHTML = "";
        (s.vehicles ?? []).forEach(v => els.vehiclesTbody.appendChild(vehicleRow(v.name, v.liters)));

        els.hydrantsTbody.innerHTML = "";
        (s.hydrants ?? []).forEach(h => els.hydrantsTbody.appendChild(hydrantRow(h.desc, h.type, h.count)));

        els.tanksTbody.innerHTML = "";
        (s.tanks ?? []).forEach(t => els.tanksTbody.appendChild(tankRow(t.desc, t.volL, t.Lm, t.Wm, t.Dm)));

        els.riversTbody.innerHTML = "";
        (s.rivers ?? []).forEach(r => els.riversTbody.appendChild(riverRow(r.desc, r.w, r.d, r.q_m3s)));

        els.streamsTbody.innerHTML = "";
        (s.streams ?? []).forEach(st => els.streamsTbody.appendChild(streamRow(st.desc, st.one, st.count)));

        recalcLive();
        return true;
      } catch {
        return false;
      }
    }

    function resetAll() {
      localStorage.removeItem("kalkulator_wody_state_singlefile");
      location.reload();
    }

    // --------------------
    // IMGW: uśrednienie przepływu po województwie (opcjonalnie)
    // UWAGA: przy file:// / content:// fetch może być blokowany przez przeglądarkę.
    // --------------------
    async function fetchImgwHydro() {
      const url = "https://danepubliczne.imgw.pl/api/data/hydro/format/json";
      const resp = await fetch(url, { cache: "no-store" });
      if (!resp.ok) throw new Error(`IMGW HTTP ${resp.status}`);
      return await resp.json();
    }

    function normalizeVoivodeship(v) {
      return String(v || "")
        .toLowerCase()
        .replace(/ą/g, "a").replace(/ć/g, "c").replace(/ę/g, "e").replace(/ł/g, "l")
        .replace(/ń/g, "n").replace(/ó/g, "o").replace(/ś/g, "s").replace(/ż/g, "z").replace(/ź/g, "z")
        .trim();
    }

    function robustMean(values) {
      const xs = values.filter(x => Number.isFinite(x) && x > 0).sort((a,b)=>a-b);
      if (xs.length === 0) return 0;
      const cut = Math.floor(xs.length * 0.10);
      const mid = xs.slice(cut, xs.length - cut);
      const arr = (mid.length > 0) ? mid : xs;
      return arr.reduce((a,b)=>a+b, 0) / arr.length;
    }

    async function applyAvgFlowToEmptyRiverRows() {
      els.fetchRiverAvg.disabled = true;
      const oldTxt = els.fetchRiverAvg.textContent;
      els.fetchRiverAvg.textContent = "Pobieram…";

      try {
        const data = await fetchImgwHydro();
        const target = normalizeVoivodeship(els.voivodeship.value);

        // uwzględnij różne warianty nazwy pola w danych (odporność)
        const flows = data
          .filter(r => normalizeVoivodeship(r.wojewodztwo) === target)
          .map(r => n(r.przelyw ?? r.przeplyw ?? 0));

        const avg = robustMean(flows); // m3/s
        if (avg <= 0) throw new Error("Brak dodatnich wartości przepływu dla województwa.");

        [...els.riversTbody.querySelectorAll("tr")].forEach(tr => {
          const inp = tr.querySelector(".r-q");
          if (inp && n(inp.value) <= 0) inp.value = String(round(avg, 3));
        });

        setStatus("neutral", "Pobrano przepływy", `Uśredniony przepływ dla "${els.voivodeship.value}" ustawiono w pustych wierszach cieków: ${round(avg, 3)} m³/s.`);
        recalcLive();
      } catch (e) {
        setStatus("bad", "Nie pobrano przepływów", `Nie udało się pobrać danych IMGW (często blokada przy uruchomieniu jako plik). Szczegóły: ${String(e.message || e)}`);
      } finally {
        els.fetchRiverAvg.disabled = false;
        els.fetchRiverAvg.textContent = oldTxt;
      }
    }

    // --------------------
    // Defaults
    // --------------------
    function initDefaultsIfNoState() {
      // wozy
      els.vehiclesTbody.appendChild(vehicleRow("GBA 3,5/29", 3500));
      els.vehiclesTbody.appendChild(vehicleRow("GBA 2,5/16", 2500));
      els.vehiclesTbody.appendChild(vehicleRow("GCBA 5/32", 5000));

      // prądy
      els.streamsTbody.appendChild(streamRow("Linia W-52 ~240 l/min", 240, 4));
      els.streamsTbody.appendChild(streamRow("Linia W-75 ~400 l/min", 400, 0));
      els.streamsTbody.appendChild(streamRow("Działko 2400", 2400, 3));
      els.streamsTbody.appendChild(streamRow("Działko 3200", 3200, 1));

      recalcLive();
    }

    // --------------------
    // Events
    // --------------------
    els.addVehicle.addEventListener("click", () => { els.vehiclesTbody.appendChild(vehicleRow("", 0)); recalcLive(); });
    els.addHydrant.addEventListener("click", () => { els.hydrantsTbody.appendChild(hydrantRow("Hydrant zewnętrzny", "DN80", 1)); recalcLive(); });
    els.addTank.addEventListener("click", () => { els.tanksTbody.appendChild(tankRow("Zbiornik", 0, 0, 0, 0)); recalcLive(); });
    els.addRiver.addEventListener("click", () => { els.riversTbody.appendChild(riverRow("Ciek", 0, 0, 0)); recalcLive(); });
    els.addStream.addEventListener("click", () => { els.streamsTbody.appendChild(streamRow("", 0, 0)); recalcLive(); });

    els.calc.addEventListener("click", compute);
    els.save.addEventListener("click", saveState);
    els.reset.addEventListener("click", resetAll);

    [els.A, els.qd, els.I, els.riverMinutes].forEach(inp => inp.addEventListener("input", recalcLive));
    els.fetchRiverAvg.addEventListener("click", applyAvgFlowToEmptyRiverRows);

    // Start
    if (!loadState()) initDefaultsIfNoState();
    setStatus("neutral", "GOTOWE", "Kliknij „Oblicz”. Możesz też zapisać ustawienia.");
  </script>
</body>
</html>
```0